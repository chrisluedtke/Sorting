# Sorting Algorithms

In this two day project, we implement many different solutions to the same problem: sorting a list of integers in ascending order. We also use our newfound knowledge of complexity analysis to evaluate each implementation for efficiency.

* follow [Polya's Problem Solving techniques](https://github.com/LambdaSchool/CS-Wiki/wiki/Polya%27s-Problem-Solving-Techniques)


# Part 1

## MVP Tasks

 - Open up the [iterative_sorting](src/iterative_sorting) directory
 - Read through the descriptions of the `bubble_sort` and `selection_sort` algorithms
 - Implement `bubble_sort` and `selection_sort` in [iterative_sorting.py](src/iterative_sorting/iterative_sorting.py)
 - Test your implementation by running `test_iterative.py`

# Part 2

## MVP Tasks

 - Open up the [recursive_sorting](src/recursive_sorting) directory
 - Read through the descriptions of the `merge_sort` algorithm
 - Implement `merge_sort` in [recursive_sorting.py](src/recursive_sorting/recursive_sorting.py)
 - Test your implementation by running `test_recursive.py`

## Stretch Goals
 - Implement all the methods in the `searching.py` file in the `searching` directory.
 - Implement the `count_sort` algorithm in the `iterative_sorting` directory.
 - Implement an in-place version of `merge_sort` that does not allocate any additional memory. In other words, the space complexity for this function should be O(1).
 - Implement the `timsort` algorithm, which is a real-world sorting algorithm. In fact, it is the sorting algorithm that is used when you run Python's built-in `sort` method. 
